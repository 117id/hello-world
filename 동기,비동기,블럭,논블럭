< 개별 정의 >

- 블럭/논블럭

: 블럭/논블럭은 함수호출에서의 이야기이다. (기술적으로 명확히 구분)

ex) A라는 함수를 호출 했을때, A라는 함수를 호출 했을 때 기대하는 행위를 모두 끝마칠때까지 기다렸다가 리턴 => 블로킹

ex) A라는 함수를 호출 했을때, A라는 함수를 호출 했을 때 기대하는 어떤 행위를 요청하고 바로 리턴되면 이것은 논 블록킹 되었다고 한다.

1) 블로킹 : 애플리케이션 실행 시 운영체제 대기 큐에 들어가면서 요청에 대한 system calll이 완료된 후에 응답을 보낸다.

2) 논 블로킹 : 애플리케이션 실행 시 운영체제 대기 큐에 들어기자 않음, 실행 여부와 관계없이 바로 응답을 보낸다. 바로 응답하기 힘든 경우, 에러를 반환하는데 정상 뎅터를 받을 때까지 계속해서 요청을 다시 보낸다.

* IO이벤트 통지모델은 논블로킹에서 제기된 문제를 해결하기 위해 고안되었다. IO 이벤트를 통지하는 방법



- 동기/비동기 

: 동기/비동기는 행위에 대한 이야기다. (기술적으로 구분 안되며,추상적 구분)

ex) A라는 행위, B라는 별개의 행위

1) A라는 행위와 B라는 행위가 동시(순차적이지 않음)에 실행 => 비동기

하지만 제약이 존재, A와B 사이에 인과관계가 있어야 함,

(ex) 웹서버 : 멀티쓰레드로 각각 A,B가 다른 클라이언트와 작업 

=> 둘은 동시에 작업, but 둘의 인과관계는 없다. )

2) A라는 행위와 B라는 행위가 순차적으로 작동시 동기

+ A라는 행위가 별개의 것이 아니라, B라는 행위를 관찰하는 행위라면 이것이 동시에 일어나더라도 동기이다.

ex) 기술적관점에서 A라는 쓰레드와 B라는 쓰레드가 따로 돌아간다고 해도, 하나의 행위가 다른 행위에 밀착되어 있다면 두 행위가 다른 쓰레드에서 벌어지더라도 동기이다.

1) 동기 : 시스템콜을 기다린다(notify를 사용자 프로세스가 담당) 시스템 반환을 기다리는 동안 대기 큐에 머무는 것이 필수는 아니다( 블로킹은 필수임 )

2) 비동기 : 시스템콜을 기다리지 않는다.(notify를 커널이 담당) 요청에 대해 처리 완료여부와 관련없이 응답하고 다음코드를 돌린다. 이후에 운영체제에서 처리완료여부를 알려주고 응답한다.
